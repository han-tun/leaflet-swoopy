{"version":3,"file":"Leaflet.SwoopyArrow.min.js","sources":["../node_modules/@webk1d/leaflet-curve/leaflet.curve.js","../node_modules/@turf/helpers/main.es.js","../node_modules/@turf/meta/main.es.js","../node_modules/@turf/bbox/main.es.js","../node_modules/@turf/center/main.es.js","../src/index.js"],"sourcesContent":["/*\r\n * Leaflet.curve v0.1.0 - a plugin for Leaflet mapping library. https://github.com/elfalem/Leaflet.curve\r\n * (c) elfalem 2015\r\n */\r\n/*\r\n * note that SVG (x, y) corresponds to (long, lat)\r\n */\r\n\r\nL.Curve = L.Path.extend({\r\n\toptions: {\r\n\t},\r\n\t\r\n\tinitialize: function(path, options){\r\n\t\tL.setOptions(this, options);\r\n\t\tthis._initialUpdate = true;\r\n\t\tthis._setPath(path);\r\n\t},\r\n\t\r\n\tgetPath: function(){\r\n\t\treturn this._coords;\r\n\t},\r\n\t\r\n\tsetPath: function(path){\r\n\t\tthis._setPath(path);\r\n\t\treturn this.redraw();\r\n\t},\r\n\t\r\n\tgetBounds: function() {\r\n\t\treturn this._bounds;\r\n\t},\r\n\r\n\t_setPath: function(path){\r\n\t\tthis._coords = path;\r\n\t\tthis._bounds = this._computeBounds();\r\n\t},\r\n\t\r\n\t_computeBounds: function(){\r\n\t\tvar bound = new L.LatLngBounds();\r\n\t\tvar lastPoint;\r\n\t\tvar lastCommand;\r\n\t\tvar coord;\r\n\t\tfor(var i = 0; i < this._coords.length; i++){\r\n\t\t\tcoord = this._coords[i];\r\n\t\t\tif(typeof coord == 'string' || coord instanceof String){\r\n\t\t\t\tlastCommand = coord;\r\n\t\t\t}else if(lastCommand == 'H'){\r\n\t\t\t\tbound.extend([lastPoint.lat,coord[0]]);\r\n\t\t\t\tlastPoint = new L.latLng(lastPoint.lat,coord[0]);\r\n\t\t\t}else if(lastCommand == 'V'){\r\n\t\t\t\tbound.extend([coord[0], lastPoint.lng]);\r\n\t\t\t\tlastPoint = new L.latLng(coord[0], lastPoint.lng);\r\n\t\t\t}else if(lastCommand == 'C'){\r\n\t\t\t\tvar controlPoint1 = new L.latLng(coord[0], coord[1]);\r\n\t\t\t\tcoord = this._coords[++i];\r\n\t\t\t\tvar controlPoint2 = new L.latLng(coord[0], coord[1]);\r\n\t\t\t\tcoord = this._coords[++i];\r\n\t\t\t\tvar endPoint = new L.latLng(coord[0], coord[1]);\r\n\r\n\t\t\t\tbound.extend(controlPoint1);\r\n\t\t\t\tbound.extend(controlPoint2);\r\n\t\t\t\tbound.extend(endPoint);\r\n\r\n\t\t\t\tendPoint.controlPoint1 = controlPoint1;\r\n\t\t\t\tendPoint.controlPoint2 = controlPoint2;\r\n\t\t\t\tlastPoint = endPoint;\r\n\t\t\t}else if(lastCommand == 'S'){\r\n\t\t\t\tvar controlPoint2 = new L.latLng(coord[0], coord[1]);\r\n\t\t\t\tcoord = this._coords[++i];\r\n\t\t\t\tvar endPoint = new L.latLng(coord[0], coord[1]);\r\n\r\n\t\t\t\tvar controlPoint1 = lastPoint;\r\n\t\t\t\tif(lastPoint.controlPoint2){\r\n\t\t\t\t\tvar diffLat = lastPoint.lat - lastPoint.controlPoint2.lat;\r\n\t\t\t\t\tvar diffLng = lastPoint.lng - lastPoint.controlPoint2.lng;\r\n\t\t\t\t\tcontrolPoint1 = new L.latLng(lastPoint.lat + diffLat, lastPoint.lng + diffLng);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbound.extend(controlPoint1);\r\n\t\t\t\tbound.extend(controlPoint2);\r\n\t\t\t\tbound.extend(endPoint);\r\n\r\n\t\t\t\tendPoint.controlPoint1 = controlPoint1;\r\n\t\t\t\tendPoint.controlPoint2 = controlPoint2;\r\n\t\t\t\tlastPoint = endPoint;\r\n\t\t\t}else if(lastCommand == 'Q'){\r\n\t\t\t\tvar controlPoint = new L.latLng(coord[0], coord[1]);\r\n\t\t\t\tcoord = this._coords[++i];\r\n\t\t\t\tvar endPoint = new L.latLng(coord[0], coord[1]);\r\n\r\n\t\t\t\tbound.extend(controlPoint);\r\n\t\t\t\tbound.extend(endPoint);\r\n\r\n\t\t\t\tendPoint.controlPoint = controlPoint;\r\n\t\t\t\tlastPoint = endPoint;\r\n\t\t\t}else if(lastCommand == 'T'){\r\n\t\t\t\tvar endPoint = new L.latLng(coord[0], coord[1]);\r\n\r\n\t\t\t\tvar controlPoint = lastPoint;\r\n\t\t\t\tif(lastPoint.controlPoint){\r\n\t\t\t\t\tvar diffLat = lastPoint.lat - lastPoint.controlPoint.lat;\r\n\t\t\t\t\tvar diffLng = lastPoint.lng - lastPoint.controlPoint.lng;\r\n\t\t\t\t\tcontrolPoint = new L.latLng(lastPoint.lat + diffLat, lastPoint.lng + diffLng);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbound.extend(controlPoint);\r\n\t\t\t\tbound.extend(endPoint);\r\n\r\n\t\t\t\tendPoint.controlPoint = controlPoint;\r\n\t\t\t\tlastPoint = endPoint;\r\n\t\t\t}else{\r\n\t\t\t\tbound.extend(coord);\r\n\t\t\t\tlastPoint = new L.latLng(coord[0], coord[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn bound;\r\n\t},\r\n\t\r\n\t//TODO: use a centroid algorithm instead\r\n\tgetCenter: function () {\r\n\t\treturn this._bounds.getCenter();\r\n\t},\r\n\t\r\n\t_update: function(){\r\n\t\tif (!this._map) { return; }\r\n\t\t\r\n\t\tthis._updatePath();\r\n\t},\r\n\t\r\n\t_updatePath: function() {\r\n\t\tthis._renderer._updatecurve(this);\r\n\t},\r\n\r\n\t_project: function() {\r\n\t\tvar coord, lastCoord, curCommand, curPoint;\r\n\r\n\t\tthis._points = [];\r\n\t\t\r\n\t\tfor(var i = 0; i < this._coords.length; i++){\r\n\t\t\tcoord = this._coords[i];\r\n\t\t\tif(typeof coord == 'string' || coord instanceof String){\r\n\t\t\t\tthis._points.push(coord);\r\n\t\t\t\tcurCommand = coord;\r\n\t\t\t}else {\r\n\t\t\t\tswitch(coord.length){\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcurPoint = this._map.latLngToLayerPoint(coord);\r\n\t\t\t\t\t\tlastCoord = coord;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tif(curCommand == 'H'){\r\n\t\t\t\t\t\t\tcurPoint = this._map.latLngToLayerPoint([lastCoord[0], coord[0]]);\r\n\t\t\t\t\t\t\tlastCoord = [lastCoord[0], coord[0]];\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tcurPoint = this._map.latLngToLayerPoint([coord[0], lastCoord[1]]);\r\n\t\t\t\t\t\t\tlastCoord = [coord[0], lastCoord[1]];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tthis._points.push(curPoint);\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n});\r\n\r\nL.curve = function (path, options){\r\n\treturn new L.Curve(path, options);\r\n};\r\n\r\nL.SVG.include({\r\n\t_updatecurve: function(layer){\r\n\t\tthis._setPath(layer, this._curvePointsToPath(layer._points));\r\n\r\n\t\tif(layer.options.animate){\r\n\t\t\tvar path = layer._path;\r\n\t\t\tvar length = path.getTotalLength();\r\n\t\t\t\r\n\t\t\tif(!layer.options.dashArray){\r\n\t\t\t\tpath.style.strokeDasharray = length + ' ' + length;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(layer._initialUpdate){\r\n\t\t\t\tpath.animate([\r\n\t\t\t\t\t\t{strokeDashoffset: length},\r\n\t\t\t\t\t\t{strokeDashoffset: 0}\r\n\t\t\t\t\t], layer.options.animate);\r\n\t\t\t\tlayer._initialUpdate = false;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n \t_curvePointsToPath: function(points){\r\n\t\tvar point, curCommand, str = '';\r\n\t\tfor(var i = 0; i < points.length; i++){\r\n\t\t\tpoint = points[i];\r\n\t\t\tif(typeof point == 'string' || point instanceof String){\r\n\t\t\t\tcurCommand = point;\r\n\t\t\t\tstr += curCommand;\r\n\t\t\t}else{\r\n\t\t\t\tswitch(curCommand){\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tstr += point.x + ' ';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tstr += point.y + ' ';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tstr += point.x + ',' + point.y + ' ';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn str || 'M0 0';\r\n\t}\r\n});\r\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { coordEach } from '@turf/meta';\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var BBox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (BBox[0] > coord[0]) BBox[0] = coord[0];\n        if (BBox[1] > coord[1]) BBox[1] = coord[1];\n        if (BBox[2] < coord[0]) BBox[2] = coord[0];\n        if (BBox[3] < coord[1]) BBox[3] = coord[1];\n    });\n    return BBox;\n}\n\nexport default bbox;\n","import bbox from '@turf/bbox';\nimport { isObject, point } from '@turf/helpers';\n\n/**\n * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.\n *\n * @name center\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties\n * @returns {Feature<Point>} a Point feature at the absolute center point of all input features\n * @example\n * var features = turf.featureCollection([\n *   turf.point( [-97.522259, 35.4691]),\n *   turf.point( [-97.502754, 35.463455]),\n *   turf.point( [-97.508269, 35.463245])\n * ]);\n *\n * var center = turf.center(features);\n *\n * //addToMap\n * var addToMap = [features, center]\n * center.properties['marker-size'] = 'large';\n * center.properties['marker-color'] = '#000';\n */\nfunction center(geojson, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var properties = options.properties;\n\n    // Input validation\n    if (!geojson) throw new Error('geojson is required');\n\n    var ext = bbox(geojson);\n    var x = (ext[0] + ext[2]) / 2;\n    var y = (ext[1] + ext[3]) / 2;\n    return point([x, y], properties);\n}\n\nexport default center;\n","import L from 'leaflet';\nimport '@webk1d/leaflet-curve';\nimport {\n  featureCollection as turfFeatureCollection,\n  point as turfPoint\n} from '@turf/helpers';\nimport turfCenter from '@turf/center';\n\nlet id = 0;\n\nL.SwoopyArrow = L.Layer.extend({\n  fromLatlng: [],\n  toLatlng: [],\n  options: {\n    color: '#222222',\n    weight: 1,\n    opacity: 1,\n    factor: 0.5,\n    arrowFilled: false,\n    hideArrowHead: false,\n    arrowId: null,\n    minZoom: 0,\n    maxZoom: 22,\n    label: '',\n    labelClassName: '',\n    labelFontSize: 12,\n    labelColor: '#222222',\n    html: '',\n    iconAnchor: [0, 0],\n    iconSize: [50, 20],\n    keyboard: true,\n  },\n\n  initialize: function (fromLatlng, toLatlng, options) {\n    L.Util.setOptions(this, options);\n\n    this._currentPathVisible = true;\n    this._fromLatlng = L.latLng(fromLatlng);\n    this._toLatlng = L.latLng(toLatlng);\n    this._factor = this.options.factor;\n    this._label = this.options.label;\n    this._labelFontSize = this.options.labelFontSize;\n    this._labelColor = this.options.labelColor;\n    this._color = this.options.color;\n    this._labelClassName = this.options.labelClassName;\n    this._html = this.options.html;\n    this._opacity = this.options.opacity;\n    this._minZoom = this.options.minZoom;\n    this._maxZoom = this.options.maxZoom;\n    this._iconAnchor = this.options.iconAnchor;\n    this._iconSize = this.options.iconSize;\n    this._weight = this.options.weight;\n    this._arrowFilled = this.options.arrowFilled;\n    this._hideArrowHead = this.options.hideArrowHead;\n    this._arrowId = this.options.arrowId;\n    this._keyboard = this.options.keyboard;\n\n    this._initSVG();\n  },\n\n  _initSVG: function () {\n    this._svg = L.SVG.create('svg');\n    this._currentId = id++;\n    this._arrow = this._createArrow();\n    this._svg.appendChild(this._arrow);\n  },\n\n  onAdd: function (map) {\n    this._map = map;\n    this.getPane().appendChild(this._svg);\n\n    this._drawSwoopyArrows();\n\n    this.update(this._map);\n  },\n\n  getEvents: function () {\n    return {\n      zoom: this.update,\n      viewreset: this.update\n    };\n  },\n\n  _drawSwoopyArrows: function() {\n    const swoopyPath = this._createPath();\n    this._currentPath = swoopyPath._path;\n\n    const swoopyLabel = this._createLabel();\n    this._currentMarker = L.marker([this._fromLatlng.lat, this._fromLatlng.lng], { icon: swoopyLabel, keyboard: this._keyboard }).addTo(this._map);\n  },\n\n  _createArrow: function () {\n    this._container = this._container || L.SVG.create('defs');\n    const marker = L.SVG.create('marker');\n    const path = L.SVG.create('polyline');\n\n    marker.setAttribute('class', 'swoopyArrow__marker');\n    marker.setAttribute('id', `swoopyarrow__arrowhead${this._currentId}`);\n    marker.setAttribute('markerWidth', '6.75');\n    marker.setAttribute('markerHeight', '6.75');\n    marker.setAttribute('viewBox', '-10 -10 20 20');\n    marker.setAttribute('orient', 'auto');\n    marker.setAttribute('refX', '0');\n    marker.setAttribute('refY', '0');\n    marker.setAttribute('fill', 'none');\n    marker.setAttribute('stroke', this._color);\n    marker.setAttribute('stroke-width', this._weight);\n    marker.setAttribute('opacity', this._opacity);\n\n    if(!this._hideArrowHead) {\n      path.setAttribute('stroke-linejoin', 'bevel');\n      path.setAttribute('fill', this._arrowFilled ? this._color : 'none');\n      path.setAttribute('stroke', this._color);\n      path.setAttribute('points', '-6.75,-6.75 0,0 -6.75,6.75');\n      marker.appendChild(path);\n    }\n\n    this._container.appendChild(marker);\n\n    return this._container;\n  },\n\n  _createPath: function () {\n    const controlLatlng = this._getControlPoint(L.latLng(this._fromLatlng), L.latLng(this._toLatlng), this.options.factor);\n    const pathOne = L.curve([\n      'M', [this._fromLatlng.lat, this._fromLatlng.lng],\n      'Q', [controlLatlng.lat, controlLatlng.lng], [this._toLatlng.lat, this._toLatlng.lng]\n      ], {\n        animate: false,\n        color: this._color,\n        fill: false,\n        opacity: this._opacity,\n        weight: this._weight,\n        className: 'swoopyarrow__path'\n      }\n    ).addTo(this._map);\n\n\n    pathOne._path.setAttribute('id', `swoopyarrow__path${this._currentId}`);\n    pathOne._path.setAttribute('marker-end', !this._arrowId ?\n      `url(#swoopyarrow__arrowhead${this._currentId})` :\n      `url(${this._arrowId})`\n     );\n\n    return pathOne;\n  },\n\n\n  _rotatePoint: function (origin, point, angle) {\n    const radians = angle * Math.PI / 180.0;\n\n    return {\n      x: Math.cos(radians) * (point.x - origin.x) - Math.sin(radians) * (point.y - origin.y) + origin.x,\n      y: Math.sin(radians) * (point.x - origin.x) + Math.cos(radians) * (point.y - origin.y) + origin.y\n    };\n  },\n\n  _getControlPoint: function (start, end, factor) {\n    const features = turfFeatureCollection([\n      turfPoint([start.lat, start.lng]),\n      turfPoint([end.lat, end.lng])\n    ]);\n\n    const center = turfCenter(features);\n\n    // get pixel coordinates for start, end and center\n    const startPx = this._map.latLngToContainerPoint(start);\n    const centerPx = this._map.latLngToContainerPoint(L.latLng(center.geometry.coordinates[0], center.geometry.coordinates[1]));\n    const rotatedPx = this._rotatePoint(centerPx, startPx, 90);\n\n    const distance = Math.sqrt(Math.pow(startPx.x - centerPx.x, 2) + Math.pow(startPx.y - centerPx.y, 2));\n    const angle = Math.atan2(rotatedPx.y - centerPx.y, rotatedPx.x - centerPx.x);\n    const offset = (factor * distance) - distance;\n\n    const sin = Math.sin(angle) * offset;\n    const cos = Math.cos(angle) * offset;\n\n    const controlPoint = L.point(rotatedPx.x + cos, rotatedPx.y + sin);\n\n    return this._map.containerPointToLatLng(controlPoint);\n  },\n\n  _createLabel: function() {\n    return L.divIcon({\n      className: this._html === '' && this._labelClassName,\n      html: this._html === ''  ? `<span id=\"marker-label${this._currentId}\" style=\"font-size: ${this._labelFontSize}px; color: ${this._labelColor}\">${this._label}</span>` : this._html,\n      iconAnchor: this._iconAnchor,\n      iconSize: this._iconSize\n    });\n  },\n\n  update: function(map) {\n    this._checkZoomLevel();\n\n    const arrowHead = this._svg.getElementById(`swoopyarrow__arrowhead${this._currentId}`);\n    arrowHead.setAttribute('markerWidth', `${2.5 * this._map.getZoom()}`);\n    arrowHead.setAttribute('markerHeight', `${2.5 * this._map.getZoom()}`);\n\n    return this;\n  },\n\n  _checkZoomLevel: function() {\n    const currentZoomLevel = this._map.getZoom();\n\n    if(!this._currentPathVisible) {\n      this._currentPath.setAttribute('opacity', this._opacity);\n      this._currentMarker.setOpacity(this._opacity);\n    }\n\n    if(currentZoomLevel < this._minZoom || currentZoomLevel > this._maxZoom) {\n      this._currentPath.setAttribute('opacity', 0);\n      this._currentMarker.setOpacity(0);\n\n      this._currentPathVisible = false;\n    }\n  },\n\n  onRemove: function(map) {\n    this._map = map;\n    this._currentPath.parentNode.removeChild(this._currentPath);\n    this._map.removeLayer(this._currentMarker);\n  }\n});\n\nL.swoopyArrow = (fromLatlng, toLatlng, options) => new L.SwoopyArrow(fromLatlng, toLatlng, options);\n"],"names":["path","options","bound","lastPoint","lastCommand","coord","i","controlPoint1","controlPoint2","endPoint","diffLat","diffLng","controlPoint","lastCoord","curCommand","curPoint","layer","length","points","point","str","feature","geometry","properties","isObject","bbox","id","validateBBox","validateId","feat","coordinates","isNumber","featureCollection","features","fc","num","input","coordEach","geojson","callback","excludeWrapCoord","j","k","l","stopG","coords","geometryMaybeCollection","wrapShrink","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","BBox","center","ext","x","y","L","SwoopyArrow","Layer","extend","fromLatlng","toLatlng","Util","setOptions","_currentPathVisible","_fromLatlng","latLng","_toLatlng","_factor","factor","_label","label","_labelFontSize","labelFontSize","_labelColor","labelColor","_color","color","_labelClassName","labelClassName","_html","html","_opacity","opacity","_minZoom","minZoom","_maxZoom","maxZoom","_iconAnchor","iconAnchor","_iconSize","iconSize","_weight","weight","_arrowFilled","arrowFilled","_hideArrowHead","hideArrowHead","_arrowId","arrowId","_keyboard","keyboard","_initSVG","_svg","SVG","create","_currentId","_arrow","_createArrow","appendChild","map","_map","getPane","_drawSwoopyArrows","update","swoopyPath","_createPath","_currentPath","_path","swoopyLabel","_createLabel","_currentMarker","marker","lat","lng","icon","addTo","_container","setAttribute","controlLatlng","_getControlPoint","pathOne","curve","origin","angle","radians","Math","PI","cos","sin","start","end","turfFeatureCollection","turfPoint","turfCenter","startPx","latLngToContainerPoint","centerPx","rotatedPx","_rotatePoint","distance","sqrt","pow","atan2","offset","containerPointToLatLng","divIcon","_checkZoomLevel","arrowHead","getElementById","getZoom","currentZoomLevel","setOpacity","parentNode","removeChild","removeLayer","swoopyArrow"],"mappings":"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"}